package Filemanager;import jdk.nashorn.internal.scripts.JO;import javax.swing.*;import javax.swing.event.TreeSelectionEvent;import javax.swing.event.TreeSelectionListener;import javax.swing.text.DefaultCaret;import javax.swing.tree.DefaultMutableTreeNode;import javax.swing.tree.TreeNode;import javax.swing.tree.TreePath;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.io.Serializable;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;//这个文件是处理UI界面后台的相关事件public class FileManagerUIController implements ActionListener,TreeSelectionListener,MouseListener,Serializable{    private static final long serialVersionUID = 1L;    private FileController fileController = null;    private FileManagerUIview fileManagerUIview = null;//放置了UI设计的jpanel的文件    private Map<DefaultMutableTreeNode, FileFCB> connectionMap = null;    public FileManagerUIController(FileController fileController,FileManagerUIview fileManagerUIview)    {        this.fileController = fileController;        this.fileManagerUIview = fileManagerUIview;        this.connectionMap = new HashMap<DefaultMutableTreeNode,FileFCB>();        DefaultMutableTreeNode rootNode = fileManagerUIview.rootNode;        FileFCB rootFCB = fileController.getRoot();        connectionMap.put(rootNode,rootFCB);        this.addListenerFromView();    }    public void addListenerFromView() {        fileManagerUIview.tree.addMouseListener(this);        fileManagerUIview.tree.addTreeSelectionListener(this);        fileManagerUIview.format.addActionListener(this);        fileManagerUIview.newDir.addActionListener(this);        fileManagerUIview.newFile.addActionListener(this);        fileManagerUIview.Delete.addActionListener(this);        fileManagerUIview.rename.addActionListener(this);        fileManagerUIview.open.addActionListener(this);        fileManagerUIview.close.addActionListener(this);        fileManagerUIview.SelectTrack.addActionListener(this);    }    @Override    public void actionPerformed(ActionEvent e) {        Object obj = e.getSource();        if(fileManagerUIview.SelectTrack == obj)        {            fileManagerUIview.remove(fileManagerUIview.jScrollPane1);            int TraceNum =(int) fileManagerUIview.jComboBox.getSelectedItem();            fileManagerUIview.diskDisplay = fileManagerUIview.Disk[TraceNum];            fileManagerUIview.jScrollPane1 = new JScrollPane(fileManagerUIview.diskDisplay);            fileManagerUIview.diskDisplay.setPreferredSize(new Dimension(580,290));            fileManagerUIview.jScrollPane1.setBounds(1000,150,600,200);            fileManagerUIview.add(fileManagerUIview.jScrollPane1);            fileManagerUIview.Cmd.LocateTrace(TraceNum);            fileManagerUIview.updateUI();        }        else if (obj == fileManagerUIview.format)        {            int result  = JOptionPane.showConfirmDialog(                    fileManagerUIview.buttonPane,                    "确定格式化磁盘吗？",                    "警告",                    JOptionPane.YES_NO_OPTION);            if (result == JOptionPane.NO_OPTION)                return ;            fileManagerUIview.rootNode.removeAllChildren();            fileManagerUIview.tree.updateUI();            fileController.formatFileSystem();            fileManagerUIview.textArea.setText(this.getRootInfo());            fileManagerUIview.Cmd.FormatDisk();            fileManagerUIview.colorPanel.setBackground(Color.white);            for (int i = 0;i<Conf.Track_num;i++)                fileManagerUIview.Disk[i].clearALLSquare();            return;        }        DefaultMutableTreeNode  selectedNode = (DefaultMutableTreeNode)                fileManagerUIview.tree.getLastSelectedPathComponent();        if(selectedNode == null)        {            JOptionPane.showMessageDialog(null,"请选择一个文件或者文件夹","错误！",                    JOptionPane.ERROR_MESSAGE);            fileManagerUIview.Cmd.Error();            return;        }         FileFCB selectedFCB = connectionMap.get(selectedNode);         FCB_Type FCBType = selectedFCB.getFCBType();         int ID = selectedFCB.getID();         if (obj == fileManagerUIview.newDir)   {          if (FCBType == FCB_Type.file)          {            JOptionPane.showMessageDialog(null,"请选择一个文件夹！","错误！"                    ,JOptionPane.ERROR_MESSAGE);              fileManagerUIview.Cmd.Error();          }          else if (FCBType == FCB_Type.directory)          {            String dirName =  this.getName(FCB_Type.directory);            if (dirName.equals("N/A"))            {                return;            }            FileFCB dirFCB = new FileFCB(dirName);            Status_Type result = fileController.createDir(dirName,ID,dirFCB);            if (result == Status_Type.all_right)            {                DefaultMutableTreeNode newDir = new DefaultMutableTreeNode(dirName,true);                selectedNode.add(newDir);                TreeNode[] nodes = fileManagerUIview.treeModel.getPathToRoot(newDir);                TreePath path = new TreePath(nodes);                if (selectedFCB.getParentID() == -1)                {                    fileManagerUIview.textArea.setText(this.getRootInfo());                }                else fileManagerUIview.textArea.setText(this.getDirInfo(selectedFCB));                fileManagerUIview.textArea.setEditable(false);                fileManagerUIview.tree.scrollPathToVisible(path);                fileManagerUIview.tree.updateUI();                connectionMap.put(newDir,dirFCB);                fileManagerUIview.Cmd.makeDir(dirFCB);            }            else {                this.showStatus(result);            }          }         }         else if (obj == fileManagerUIview.newFile)         {            if (FCBType == FCB_Type.file)            {                JOptionPane.showMessageDialog(null,"请选择文件夹新建文件！","错误！",                        JOptionPane.ERROR_MESSAGE);                fileManagerUIview.Cmd.Error();            }            else if (FCBType == FCB_Type.directory)            {                String fileName = this.getName(FCB_Type.file);                if (fileName.equals("N/A"))                    return;                FileFCB fileFCB = new FileFCB(fileName);                Status_Type result = fileController.createFile(fileName,ID,fileFCB);                if (result == Status_Type.all_right)                {                    DefaultMutableTreeNode newFile = new DefaultMutableTreeNode(fileName,false);                    selectedNode.add(newFile);                    TreeNode[] nodes = fileManagerUIview.treeModel.getPathToRoot(newFile);                    TreePath path = new TreePath(nodes);                    if (selectedFCB.getParentID() == -1)                        fileManagerUIview.textArea.setText(this.getRootInfo());                    else fileManagerUIview.textArea.setText(this.getDirInfo(selectedFCB));                    fileManagerUIview.textArea.setEditable(false);                    fileManagerUIview.tree.scrollPathToVisible(path);                    fileManagerUIview.tree.updateUI();                    int Track = fileController.getFatList().indexOf(fileFCB.getFileFat())/128;                    fileManagerUIview.Cmd.Tracktracing(Track);                    Tracktracing.UntracedNum.addElement(Track);                    new Thread(fileManagerUIview.tracktracing).start();                    int Block_num = fileController.getFatList().indexOf(fileFCB.getFileFat())%128;                    fileManagerUIview.Cmd.makeFile(fileFCB,Track,Block_num);                    fileManagerUIview.Disk[Track].paintSquare(Block_num,fileFCB.getRandomColor());                    //Tracktracing.UntracedNum.addElement(Track);                    connectionMap.put(newFile,fileFCB);                }                else                {                    this.showStatus(result);                }            }         }         else if (obj == fileManagerUIview.Delete)         {             if (selectedNode.getParent() == null)             {                 JOptionPane.showMessageDialog(null,"不能删除根节点！","错误！"                         ,JOptionPane.ERROR_MESSAGE);                 fileManagerUIview.Cmd.Error();             }             else {                 FileFCB toDeleteFCB = connectionMap.get(selectedNode);                 if (toDeleteFCB.getFCBType() == FCB_Type.directory)                 {                     fileController.deleteDir(ID);                     recursiveDeleteNode(selectedNode);                     connectionMap.remove(selectedNode) ;                 }                 else if (toDeleteFCB.getFCBType() == FCB_Type.file)                 {                     FileFAT fileFAT = toDeleteFCB.getFileFat();                     int nextID;                     int Track = fileController.getFatList().indexOf(fileFAT)/128;                     Tracktracing.UntracedNum.addElement(Track);                     fileManagerUIview.Cmd.Tracktracing(Track);                     do {                         fileFAT.setUsed(false);                         int preTrack = Track;                         Track = fileController.getFatList().indexOf(fileFAT)/128;                         if (Track != preTrack)                         {                             Tracktracing.UntracedNum.addElement(Track);                             fileManagerUIview.Cmd.Tracktracing(Track);                         }                         int BlockNum = fileController.getFatList().indexOf(fileFAT)%128;                         fileManagerUIview.Disk[Track].clearSquare(BlockNum);                         nextID = fileFAT.getNextID();                         fileFAT = fileController.searchNextFatByID(nextID);                     }while (nextID != Conf.END_OF_FAT);                     new Thread(fileManagerUIview.tracktracing).start();                     fileController.deleteFile(ID);                     connectionMap.remove(selectedNode);                 }                 fileManagerUIview.treeModel.removeNodeFromParent(selectedNode);                 fileManagerUIview.textArea.setText(this.getRootInfo());                 fileManagerUIview.textArea.setEditable(false);                 fileManagerUIview.Cmd.Delete(toDeleteFCB);                 fileManagerUIview.colorPanel.setBackground(Color.white);                 System.out.println(fileController.getFatList().size());             }         }         else if (obj == fileManagerUIview.rename)         {             if (selectedNode.getParent() == null)             {                 JOptionPane.showMessageDialog(null,"不能重命名根节点！","错误！"                         ,JOptionPane.ERROR_MESSAGE);                 fileManagerUIview.Cmd.Error();             }else             {                 FileFCB toRameFCB = connectionMap.get(selectedNode);                 String oldname = toRameFCB.getFilename();                 JOptionPane optionPane = new JOptionPane("请输入新名字：",JOptionPane.QUESTION_MESSAGE                                                         ,JOptionPane.CANCEL_OPTION);                 optionPane.setInitialSelectionValue(toRameFCB.getFilename());                 JDialog dialog = optionPane.createDialog("重命名");                 optionPane.setWantsInput(true);                 optionPane.setInputValue("N/A");                 dialog.setVisible(true);                 String newName = (String)optionPane.getInputValue();                 if (newName.equals("N/A"))                     return;                 Status_Type result = fileController.rename(toRameFCB.getID(),newName);                  if (result == Status_Type.all_right)                  {                      selectedNode.setUserObject(newName);                      if (toRameFCB.getFCBType()== FCB_Type.directory)                          fileManagerUIview.textArea.setText(this.getDirInfo(toRameFCB));                      else fileManagerUIview.textArea.setText(this.getFileInfo(toRameFCB));                      if (selectedNode.isRoot())                          fileManagerUIview.textArea.setText(this.getRootInfo());                      fileManagerUIview.tree.updateUI();                      fileManagerUIview.Cmd.rename(toRameFCB,oldname);                  }else                  {                      this.showStatus(result);                  }             }         }         else if (obj == fileManagerUIview.open)         {              if (selectedNode.getAllowsChildren())              {                  JOptionPane.showMessageDialog(null,"请选择一个文件打开！","打开错误！",                          JOptionPane.ERROR_MESSAGE);                  fileManagerUIview.Cmd.Error();              }              else {                  fileManagerUIview.Delete.setEnabled(false);                  fileManagerUIview.format.setEnabled(false);                  fileManagerUIview.rename.setEnabled(false);                  fileManagerUIview.open.setEnabled(false);                  fileManagerUIview.close.setEnabled(true);                   FileFCB  toOpenFCB = connectionMap.get(selectedNode)  ;                   fileManagerUIview.textArea.setEditable(true);                   fileManagerUIview.textArea.setText(fileController.readFile(toOpenFCB.getID()));                  FileFAT fileFAT = toOpenFCB.getFileFat();                  int nextID;                  int Track = fileController.getFatList().indexOf(fileFAT)/128;                  fileManagerUIview.Cmd.Tracktracing(Track);                  Tracktracing.UntracedNum.addElement(Track);                  do {                      int preTrack = Track;                      Track = fileController.getFatList().indexOf(fileFAT)/128;                      if (Track != preTrack)                      {                          Tracktracing.UntracedNum.addElement(Track);                          fileManagerUIview.Cmd.Tracktracing(Track);                      }                      int BlockNum = fileController.getFatList().indexOf(fileFAT)%128;                      nextID = fileFAT.getNextID();                      fileFAT = fileController.searchNextFatByID(nextID);                  }while (nextID != Conf.END_OF_FAT);                  new Thread(fileManagerUIview.tracktracing).start();                   fileManagerUIview.Cmd.openFile(toOpenFCB);              }         }         else if (obj == fileManagerUIview.close)         {             if (selectedNode.getAllowsChildren())             {                 JOptionPane.showMessageDialog(null,"请选择一个文件打开！","错误！",                         JOptionPane.ERROR_MESSAGE);                 fileManagerUIview.Cmd.Error();             }             else {                 FileFCB toSaveFile = connectionMap.get(selectedNode);                 FileFAT fileFAT = toSaveFile.getFileFat();                 int nextID;                 int Track = fileController.getFatList().indexOf(fileFAT)/128;                 //Tracktracing.UntracedNum.addElement(Track);                 //fileManagerUIview.Cmd.Tracktracing(Track);                 do {                     fileFAT.setUsed(false);                     Track = fileController.getFatList().indexOf(fileFAT)/128;                     int BlockNum = fileController.getFatList().indexOf(fileFAT)%128;                     fileManagerUIview.Disk[Track].clearSquare(BlockNum);                     nextID = fileFAT.getNextID();                     fileFAT = fileController.searchNextFatByID(nextID);                 }while (nextID != Conf.END_OF_FAT);                 Status_Type result = fileController.saveFile(toSaveFile.getID(),fileManagerUIview.textArea.getText());                 if (result!=Status_Type.all_right)                 {                     this.showStatus(result);                     return;                 }                 fileFAT = toSaveFile.getFileFat();                 Track = fileController.getFatList().indexOf(fileFAT)/128;                 fileManagerUIview.Cmd.Tracktracing(Track);                 Tracktracing.UntracedNum.addElement(Track);                 do {                     //fileFAT.setUsed(false);                     int preTrack = Track;                     Track = fileController.getFatList().indexOf(fileFAT)/128;                     if (Track != preTrack)                     {                         Tracktracing.UntracedNum.addElement(Track);                         fileManagerUIview.Cmd.Tracktracing(Track);                     }                     int BlockNum = fileController.getFatList().indexOf(fileFAT)%128;                     fileManagerUIview.Disk[Track].paintSquare(BlockNum,toSaveFile.getRandomColor());                     nextID = fileFAT.getNextID();                     fileFAT = fileController.searchNextFatByID(nextID);                 }while (nextID != Conf.END_OF_FAT);                 new Thread(fileManagerUIview.tracktracing).start();                 fileManagerUIview.Delete.setEnabled(true);                 fileManagerUIview.format.setEnabled(true);                 fileManagerUIview.rename.setEnabled(true);                 fileManagerUIview.close.setEnabled(false);                 fileManagerUIview.open.setEnabled(true);                 fileManagerUIview.textArea.setText(this.getFileInfo(selectedFCB));                 fileManagerUIview.textArea.setEditable(false);                 fileManagerUIview.Cmd.closeFile(toSaveFile);             }         }    }    @Override    public void valueChanged(TreeSelectionEvent e) {            JTree tree = (JTree) e.getSource();            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode)tree.getLastSelectedPathComponent();        if (selectedNode == null)            return ;        FileFCB toShowFCB = connectionMap.get(selectedNode);        if (selectedNode.getAllowsChildren()) {            fileManagerUIview.newDir.setEnabled(true);            fileManagerUIview.newFile.setEnabled(true);            fileManagerUIview.open.setEnabled(false);            fileManagerUIview.close.setEnabled(false);            fileManagerUIview.textArea.setText(this.getDirInfo(toShowFCB));            fileManagerUIview.textArea.setEditable(false);            fileManagerUIview.colorPanel.setBackground(Color.white);            fileManagerUIview.colorPanel.updateUI();           // fileManagerUIview.textArea.setBackground(Color.white);        } else {            fileManagerUIview.open.setEnabled(true);            fileManagerUIview.close.setEnabled(false);            fileManagerUIview.newFile.setEnabled(false);            fileManagerUIview.newDir.setEnabled(false);            fileManagerUIview.textArea.setText(this.getFileInfo(toShowFCB));            fileManagerUIview.colorPanel.setBackground(toShowFCB.getRandomColor());            fileManagerUIview.colorPanel.updateUI();            fileManagerUIview.textArea.setEditable(false);        }        // 根结点的处理        if (selectedNode.isRoot()) {            fileManagerUIview.textArea.setText(this.getRootInfo());            fileManagerUIview.textArea.setEditable(false);            fileManagerUIview.colorPanel.setBackground(Color.white);            fileManagerUIview.colorPanel.updateUI();           // fileManagerUIview.textArea.setBackground(Color.white);        }        fileManagerUIview.Delete.setEnabled(true);        fileManagerUIview.format.setEnabled(true);        fileManagerUIview.rename.setEnabled(true);        fileManagerUIview.Cmd.select(toShowFCB);    }    @Override    public void mousePressed(MouseEvent e) {        TreePath treePath = fileManagerUIview.tree.getPathForLocation(e.getX(),e.getY());        if (treePath!=null)        {            fileManagerUIview.movePath = treePath;        }    }    @Override    public void mouseReleased(MouseEvent e) {        TreePath treePath = fileManagerUIview.tree.getPathForLocation(e.getX(), e.getY());        if (treePath != null && fileManagerUIview.movePath != null)        {            if (fileManagerUIview.movePath.isDescendant(treePath) &&                    fileManagerUIview.movePath != treePath) {                // 错误的移动                JOptionPane.showMessageDialog(null,                        "不能移动此节点到此地！",                        "移动错误！",                        JOptionPane.ERROR_MESSAGE);                return ;            } else if (fileManagerUIview.movePath != treePath) {                // 不是向子节点移动，且鼠标按下、松开时不是同一个节点                DefaultMutableTreeNode parentNode =                        (DefaultMutableTreeNode) treePath.getLastPathComponent();                FileFCB parentFCB = connectionMap.get(parentNode);                DefaultMutableTreeNode childNode =                        (DefaultMutableTreeNode) fileManagerUIview.movePath.getLastPathComponent();                if (!parentNode.getAllowsChildren()) {                    JOptionPane.showMessageDialog(null,                            "请选择一个文件夹作为目的地！",                            "移动错误！",                            JOptionPane.ERROR_MESSAGE);                    return ;                }                FileFCB childFCB = connectionMap.get(childNode);                Status_Type result = fileController.move(childFCB.getID(), parentFCB.getID());                if (result == Status_Type.all_right) {                    parentNode.add(childNode);                    fileManagerUIview.movePath = null;                    fileManagerUIview.tree.updateUI();                } else {                    this.showStatus(result);                }            }        }    }    public void setFileManagerUIview(FileManagerUIview fileManagerUIview) {        this.fileManagerUIview = fileManagerUIview;    }    public void setFileController(FileController fileController) {        this.fileController = fileController;    }    public FileController getFileController() {        return fileController;    }    public FileManagerUIview getFileManagerUIview() {        return this.fileManagerUIview;    }    public Map<DefaultMutableTreeNode, FileFCB> getConnectionMap() {        return connectionMap;    }    public void setConnectionMap(Map<DefaultMutableTreeNode, FileFCB> connectionMap) {        this.connectionMap = connectionMap;    }    private void recursiveDeleteNode(DefaultMutableTreeNode toDeleteNode)    {        Enumeration<DefaultMutableTreeNode> children = toDeleteNode.children();        for (Enumeration<DefaultMutableTreeNode> e = children;children.hasMoreElements();)        {            DefaultMutableTreeNode tmpNode = e.nextElement();            if (tmpNode.getChildCount()!=0)            {                recursiveDeleteNode(tmpNode);            }            connectionMap.remove(tmpNode);        }    }    private void showStatus(Status_Type status)    {        if (status == Status_Type.dupilication_of_name)        {            JOptionPane.showMessageDialog(null,"重名错误！","错误！"                    ,JOptionPane.ERROR_MESSAGE);            fileManagerUIview.Cmd.dupilication_of_name();        }        else if (status == Status_Type.illegal_name)        {            JOptionPane.showMessageDialog(null,"非法名称！","错误！",                    JOptionPane.ERROR_MESSAGE);            fileManagerUIview.Cmd.illegal_name();        }        else if (status == Status_Type.memory_lack)        {            JOptionPane.showMessageDialog(null,"硬盘空间不足！","错误！",                    JOptionPane.ERROR_MESSAGE);            fileManagerUIview.Cmd.memory_lack();        }    }    private String getName(FCB_Type FCBType)    {        JOptionPane optionPane = null;        JDialog dialog = null;        if (FCBType == FCB_Type.directory)        {            optionPane = new JOptionPane("请输入新文件夹的名称：",                    JOptionPane.QUESTION_MESSAGE,JOptionPane.CANCEL_OPTION);            optionPane.setInitialSelectionValue("new_directory");            dialog = optionPane.createDialog("新建文件夹");        }        else if (FCBType == FCB_Type.file)        {            optionPane = new JOptionPane("请输入新文件的名称：",                    JOptionPane.QUESTION_MESSAGE,JOptionPane.CANCEL_OPTION);            optionPane.setInitialSelectionValue("new_file");            dialog = optionPane.createDialog("新建文件");        }        optionPane.setWantsInput(true);        optionPane.setInputValue("N/A");        dialog.setVisible(true);        return  (String)optionPane.getInputValue();    }    private String getDirInfo(FileFCB dirFCB)    {      String name = dirFCB.getFilename();      Date createDate = null;      Date modifyDate = null;        try {            createDate = this.getData(dirFCB.getCreateDate());            modifyDate = this.getData(dirFCB.getModifyDate());        } catch (ParseException e) {            e.printStackTrace();        }        String type = null;        if (dirFCB.getFCBType() == FCB_Type.directory)        {             type = "文件夹";        }        else type = "文件";        String size = String.format(dirFCB.getFileSize()+"Byte");        int subNumber = fileController.getSubNumber(dirFCB.getID()) ;        return  String.format(             "文件名:   " + name +             "\n创建时间:   " + createDate +             "\n类型：  "+  type+             "\n修改时间:  " + modifyDate +             "\n大小:  " + size +             "\n子文件数量:  " + subNumber);    }    private String getFileInfo(FileFCB fileFCB)    {        String name = fileFCB.getFilename();        Date createDate = null,modifyDate = null;        try {            createDate = this.getData(fileFCB.getCreateDate());            modifyDate = this.getData(fileFCB.getModifyDate());        }   catch (ParseException e1)        {            e1.printStackTrace();        }        String type = null;        if (fileFCB.getFCBType() == FCB_Type.directory)        {            type = "文件夹";        }        else type = "文件";        String size = String.format(fileFCB.getFileSize()+"Byte");        String text = fileController.readFile(fileFCB.getID());        if (text.length()>Conf.MAX_TEXT)            text = String.format(text.substring(0,Conf.MAX_TEXT)+"………………\n\n请打开文件查看详细内容");        return String.format(                "名称：   "+name+                  "\n类型：   "+type                +"\n创建时间："+createDate+                        "\n修改时间：   "+modifyDate+                        "\n大小：   " +size +                        "\n-------------------------------------------------------------------------"+                         "\n  "+text        ) ;    }    private Date getData(long timeStamp) throws ParseException {        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        String d = format.format(timeStamp);        return format.parse(d);    }    private String getRootInfo() {        FileFCB rootFCB = fileController.getRoot();        String name = rootFCB.getFilename();        Date createDate = null, modifyDate = null;        try {            createDate = this.getData(rootFCB.getCreateDate());            modifyDate = this.getData(rootFCB.getModifyDate());        } catch (ParseException e1) {            e1.printStackTrace();        }        String size = String.format(fileController.getRootSize() + "  Byte");        int subNumber = fileController.getSubNumber(rootFCB.getID());        String remainSize = String.format(Conf.MEMORY_SIZE - rootFCB.getFileSize() + "  Byte");        return String.format(                "         文件名:  " + name +                        "\n创建时间:  " + createDate +                        "\n修改时间:  " + modifyDate +                        "\n             大小:  " + size +                        "\n剩余大小:  " + remainSize +                        "\n      子文件数量:  " + subNumber);    }    @Override    public void mouseClicked(MouseEvent e) {}    @Override    public void mouseEntered(MouseEvent e) {}    @Override    public void mouseExited(MouseEvent e) {}}